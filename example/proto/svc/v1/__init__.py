# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: svc/v1/testservice.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class CapsRequest(betterproto.Message):
    msg: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class CapsResponse(betterproto.Message):
    msg: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MustErrorRequest(betterproto.Message):
    err_msg: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MustErrorResponse(betterproto.Message):
    pass


class CapsServiceStub(betterproto.ServiceStub):
    async def caps(
        self,
        caps_request: "CapsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CapsResponse":
        return await self._unary_unary(
            "/svc.v1.CapsService/Caps",
            caps_request,
            CapsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def must_error(
        self,
        must_error_request: "MustErrorRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MustErrorResponse":
        return await self._unary_unary(
            "/svc.v1.CapsService/MustError",
            must_error_request,
            MustErrorResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class CapsServiceBase(ServiceBase):
    async def caps(self, caps_request: "CapsRequest") -> "CapsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def must_error(
        self, must_error_request: "MustErrorRequest"
    ) -> "MustErrorResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_caps(
        self, stream: "grpclib.server.Stream[CapsRequest, CapsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.caps(request)
        await stream.send_message(response)

    async def __rpc_must_error(
        self, stream: "grpclib.server.Stream[MustErrorRequest, MustErrorResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.must_error(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/svc.v1.CapsService/Caps": grpclib.const.Handler(
                self.__rpc_caps,
                grpclib.const.Cardinality.UNARY_UNARY,
                CapsRequest,
                CapsResponse,
            ),
            "/svc.v1.CapsService/MustError": grpclib.const.Handler(
                self.__rpc_must_error,
                grpclib.const.Cardinality.UNARY_UNARY,
                MustErrorRequest,
                MustErrorResponse,
            ),
        }
